<!DOCTYPE html>
<html>
	<head>
		<title>Hello World!</title>
		<style>
		html, body {
			min-height: 100%;
		}
		body {
			background: linear-gradient(to bottom, #f2f9fe 0%,#d6f0fd 100%);
		}
		#fps {
			position: absolute;
			top: 0;
			left: 0;
			background: white;
		}
		</style>
	</head>
	<body>
		<h1 id="fps">0 fps</h1>
		<canvas id="colorCanvas" width="1920" height="1080"></canvas>
		<script>
		//browser fps calc http://jsfiddle.net/krnlde/u1fL1cs5/
		var fpsEl = document.getElementById('fps');
		window.countFPS = (function () {
		  var lastLoop = (new Date()).getMilliseconds();
		  var count = 1;
		  var fps = 0;

		  return function () {
		    var currentLoop = (new Date()).getMilliseconds();
		    if (lastLoop > currentLoop) {
		      fps = count;
		      count = 1;
		    } else {
		      count += 1;
		    }
		    lastLoop = currentLoop;
		    return fps;
		  };
		}());
		(function loop() {
			requestAnimationFrame(function () {
				fpsEl.innerHTML = countFPS() + ' fps';
				loop();
			});
		}());
		</script>
		<script>

		(function(){
			var Kinect2 = require('../../kinect2');
			var kinect = new Kinect2();

			var currentFrame;

			var colorCanvas = document.getElementById('colorCanvas');
			var colorCtx = colorCanvas.getContext('2d');
			var colorImageData = colorCtx.createImageData(colorCanvas.width, colorCanvas.height);
			var colorImageDataSize = colorImageData.data.length;
			var colorProcessing = false;
			var colorWorkerThread = new Worker("js/colorworker.js");
			colorWorkerThread.addEventListener("message", function (event) {
				if(event.data.message === 'imageReady') {
					colorCtx.clearRect (0, 0, colorCanvas.width, colorCanvas.height);
					colorCtx.putImageData(event.data.imageData, 0, 0);
					drawSkeletons(currentFrame);
					colorProcessing = false;
				}
			});
			colorWorkerThread.postMessage({
				"message": "setImageData",
				"imageData": colorImageData
			});

			var colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#00ffff', '#ff00ff'];
			var i = 0;

			function drawSkeletons(frame) {
				var index = 0;
				frame.body.bodies.forEach(function(body){
					for(var jointName in body.joints) {
						var joint = body.joints[jointName];

						colorCtx.fillStyle = colors[index];
						colorCtx.fillRect(joint.colorX * 1920, joint.colorY * 1080, 10, 10);
					}
					index++;
				});
			}

			if(kinect.open()) {
				kinect.on('multiSourceFrame', function(frame){
					currentFrame = frame;

					//show color pixels of first user we find
					if(!colorProcessing) {
						for (var player = 0; player < frame.bodyIndexColor.bodies.length; player++) {
							if(frame.bodyIndexColor.bodies[player].buffer) {
								colorProcessing = true;
								colorWorkerThread.postMessage({ "message": "processImageData", "imageBuffer": new Uint8Array(frame.bodyIndexColor.bodies[player].buffer) });
								break;
							}
						}
						if(!colorProcessing)
						{
							//still not processing -> no body has been found, clear the canvas
							colorCtx.clearRect(0, 0, colorCanvas.width, colorCanvas.height);
						}
					}

					//body
					drawSkeletons(frame);

					//processing done
					processing = false;
				});

				kinect.openMultiSourceReader({
					frameTypes: Kinect2.FrameTypes.Body | Kinect2.FrameTypes.BodyIndexColor
				});
			}
		})();
		</script>
	</body>
</html>
